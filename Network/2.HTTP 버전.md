# HTTP
> HTTP는 TCP 기반 프로토콜로 통신 과정에서 TCP의 특성에 영향을 받음.
#### TCP 3-way Handshake 
- 통신을 시작하기 위해 클라이언트와 서버가 3단계의 패킷 교환을 거쳐하고 이 과정에서 RTT만큼의 지연시간 발생
#### TCP Slow Start
- TCP는 네트워크 혼잡을 방지하기 위해 초기 전송량을 적게 시작(혼잡 윈도우(cwnd)를 지수적으로 증가시키는 방식)하여 패킷 손실이 없을 경우에만 점진적으로 전송량을 늘림.
- 새로운 연결이 생성될 때마다 반복되어 초기 데이터 전송 지연 발생

## 1. HTTP 1.0
- 요청마다 새로운 TCP 연결을 생성하고 응답을 받은 후 연결을 종료하는 것이 기본 동작

#### ❌ 1.0의 한계
 - 요청마다 연결/종료 비용 발생 : 짧은 요청/응답을 위해 매번 3-handshake와 slow start 과정을 거침  
 - 비효율적인 통신: 웹페이지가 여러 리소스를 포함할 경우, 각각 리소스에 대해 별도의 연결을 맺고 끊는 경우 오버헤드가 큼

## 2. HTTP 1.1
HTTP 1.0의 문제를 해결하기 위해 `지속 연결`을 도입하여 tcp 커넥션 비용을 대폭 줄일 수 있음 -> TCP 연결 및 slow start 비용 절감

### HTTP keep-Alive
계층: 애플리케이션 계층
- 주로 서버가 설정된 타임아웃 시간에 따라 연결을 종료
- 클라이언트도 Connection: close 헤더를 보내 종료할 수 있음

### TCP Keep-Alive
계층: TCP 프로토콜</br>
목적: 유휴 상태의 연결이 끊어졌는지 확인(좀비 소켓 정리)</br>
방식: 운영 체제 수준에서 주기적으로 더미 패킷을 전송하여 상대방 응답 확인</br>
종료: 패킷을 보낸쪽에서 연결을 종료


#### ❌ 1.1의 한계 
- `Head of Line(HOL) Blocking` : 첫 번째 요청에 대한 응답이 지연되면, 후속 요청들은 처리가 완료될 때까지 무작정 대기해야하는 문제 발생 
- 동기적 통신이 유지


#### Head of Line(HOL) Blocking 해결책
##### Pipelining
- 서버 쪽으로 queue를 넘겨 fifo로 처리
<img width="500" height="300" alt="image" src="https://github.com/user-attachments/assets/3c70d58c-2f92-4e79-ba6e-b3b15c523938" />

- 여전히 첫 번째 요청을 서버에서 처리 못하면, 여전히 순서를 보장하지 못함
- 거의 사용되지 않음

<img width="230" height="423" alt="image" src="https://github.com/user-attachments/assets/8fcb89fe-4c42-4b93-80ed-e12dd7c604bc" />

##### Multiple Connections
- tcp 커넥션을 여러개 생성하여 병렬 연결
-  누군가가 대역폭을 많이 차지한다면 latency 증가할 수 있음.

<img width="219" height="327" alt="image" src="https://github.com/user-attachments/assets/6c90a903-b49a-40d5-92cc-e25c6c06f197" />



## Http 2
동기적 통신 문제를 해결하기 위해 `멀티플렉싱(Multiplexing)`을 도입하여 하나의 tcp 연결을 통해 다수의 클라이언트 요청 처리가 가능해짐

<img width="772" height="261" alt="image" src="https://github.com/user-attachments/assets/8a84dde9-89c4-40ea-8e91-f3fdc6d7853c" />

- **Stream 구조**: 각 요청과 응답을 독립적인 스트림으로 취급하여, 데이터를 헤더와 데이터로 구성된 프레임단위로 분할
- **비동기 처리**: 스트림들은 고유 식별자를 가지고 있어 순서에 상관없이 **동시 전송 및 처리**될 수 있음
  - 스트림 간 순서는 보장하지 않아도 됨
  - 하나의 스트림 내부 프레임은 순서를 보장해야 함.
  - 한 요청에 대한 응답이 늦어지더라도 다른 요청들에 영향을 주지 않게 됨
- 헤더 압축(HPACK): 중복되는 헤더를 압축해서 전송함으로 데이터 전송량 효율 증가
- 서버 푸시: 클라이언트가 요청하지 않은 리소스를 서버가 미리 보내 성능 최적화
   - 비효율적이라고 판단해 비활성화 추세
- 바이너리 프로토콜: 텍스트 기반에서 바이너리 기반으로 변경하여 파싱 속도 향상


#### ❌ 2의 한계 
- 애플리케이션 계층에선 HOL Blocking을 해결했지만, 하위 계층인 TCP에서 패킷 손실이 발생하면 여전히 모든 스트림이 영향을 받음. -> `TCP 레벨의 HOL Blocking`

## Http 3
위의 문제를 완전히 해결하기 위해 `UDP 기반의 QUIC 프로토콜`을 사용, UDP 기반이기 때문에 방화벽이나 프록시에 차단되는 경우가 있어 http/2와 함께 fallback으로 사용
**QUIC (Quick UDP Internet Connections)의 주요 특징**
- **UDP 기반** : 연결 설정이 간단하고, 패킷 손실이 발생해도 전체 연결이 멈추지 않음
- **0-RTT와 1-RTT 연결 설정**: TCP 3-way Handshake보다 훨씬 빠르게 연결을 맺을 수 있음
- **TLS 1.3 내장**: 암호화가 기본적으로 내장되어 있어 보안성이 강화
- **스트림 레벨 제어**: QUIC의 스트림은 개별적으로 동작하므로, 한 스트림의 패킷 손실이 다른 스트림에 영향을 주지 않음
- **연결 마이그레이션**: QUIC 프로토콜에서 connection migration은 클라이언트가 IP 주소를 변경해도 연결을 끊지 않고 유지할 수 있도록 하는 기능. 예를 들어, 노트북이 와이파이에서 LTE로 넘어갈 때 기존 연결을 유지하는 것

> 웹사이트 중 28% 이상이 HTTP/3를 사용하고 있는 것으로 나타남.
